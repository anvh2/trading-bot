// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package storagemock

import (
	"context"
	"github.com/anvh2/trading-bot/internal/models"
	"github.com/anvh2/trading-bot/internal/storage"
	"sync"
)

// Ensure, that OrderMock does implement storage.Order.
// If this is not the case, regenerate this file with moq.
var _ storage.Order = &OrderMock{}

// OrderMock is a mock implementation of storage.Order.
//
// 	func TestSomethingThatUsesOrder(t *testing.T) {
//
// 		// make and configure a mocked storage.Order
// 		mockedOrder := &OrderMock{
// 			AddQueueFunc: func(ctx context.Context, symbol string) error {
// 				panic("mock out the AddQueue method")
// 			},
// 			CloseFunc: func()  {
// 				panic("mock out the Close method")
// 			},
// 			ExistsFunc: func(ctx context.Context, symbol string) bool {
// 				panic("mock out the Exists method")
// 			},
// 			GetFunc: func(ctx context.Context, symbol string, orderId int64) (*models.Order, error) {
// 				panic("mock out the Get method")
// 			},
// 			GetAllFunc: func(ctx context.Context, symbol string) ([]*models.Order, error) {
// 				panic("mock out the GetAll method")
// 			},
// 			MSetFunc: func(ctx context.Context, symbol string, orders ...*models.Order) error {
// 				panic("mock out the MSet method")
// 			},
// 			PopQueueFunc: func(ctx context.Context) (string, error) {
// 				panic("mock out the PopQueue method")
// 			},
// 			RemoveQueueFunc: func(ctx context.Context, symbol string) error {
// 				panic("mock out the RemoveQueue method")
// 			},
// 			SetFunc: func(ctx context.Context, order *models.Order) error {
// 				panic("mock out the Set method")
// 			},
// 		}
//
// 		// use mockedOrder in code that requires storage.Order
// 		// and then make assertions.
//
// 	}
type OrderMock struct {
	// AddQueueFunc mocks the AddQueue method.
	AddQueueFunc func(ctx context.Context, symbol string) error

	// CloseFunc mocks the Close method.
	CloseFunc func()

	// ExistsFunc mocks the Exists method.
	ExistsFunc func(ctx context.Context, symbol string) bool

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, symbol string, orderId int64) (*models.Order, error)

	// GetAllFunc mocks the GetAll method.
	GetAllFunc func(ctx context.Context, symbol string) ([]*models.Order, error)

	// MSetFunc mocks the MSet method.
	MSetFunc func(ctx context.Context, symbol string, orders ...*models.Order) error

	// PopQueueFunc mocks the PopQueue method.
	PopQueueFunc func(ctx context.Context) (string, error)

	// RemoveQueueFunc mocks the RemoveQueue method.
	RemoveQueueFunc func(ctx context.Context, symbol string) error

	// SetFunc mocks the Set method.
	SetFunc func(ctx context.Context, order *models.Order) error

	// calls tracks calls to the methods.
	calls struct {
		// AddQueue holds details about calls to the AddQueue method.
		AddQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Symbol is the symbol argument value.
			Symbol string
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Symbol is the symbol argument value.
			Symbol string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Symbol is the symbol argument value.
			Symbol string
			// OrderId is the orderId argument value.
			OrderId int64
		}
		// GetAll holds details about calls to the GetAll method.
		GetAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Symbol is the symbol argument value.
			Symbol string
		}
		// MSet holds details about calls to the MSet method.
		MSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Symbol is the symbol argument value.
			Symbol string
			// Orders is the orders argument value.
			Orders []*models.Order
		}
		// PopQueue holds details about calls to the PopQueue method.
		PopQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RemoveQueue holds details about calls to the RemoveQueue method.
		RemoveQueue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Symbol is the symbol argument value.
			Symbol string
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Order is the order argument value.
			Order *models.Order
		}
	}
	lockAddQueue    sync.RWMutex
	lockClose       sync.RWMutex
	lockExists      sync.RWMutex
	lockGet         sync.RWMutex
	lockGetAll      sync.RWMutex
	lockMSet        sync.RWMutex
	lockPopQueue    sync.RWMutex
	lockRemoveQueue sync.RWMutex
	lockSet         sync.RWMutex
}

// AddQueue calls AddQueueFunc.
func (mock *OrderMock) AddQueue(ctx context.Context, symbol string) error {
	if mock.AddQueueFunc == nil {
		panic("OrderMock.AddQueueFunc: method is nil but Order.AddQueue was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Symbol string
	}{
		Ctx:    ctx,
		Symbol: symbol,
	}
	mock.lockAddQueue.Lock()
	mock.calls.AddQueue = append(mock.calls.AddQueue, callInfo)
	mock.lockAddQueue.Unlock()
	return mock.AddQueueFunc(ctx, symbol)
}

// AddQueueCalls gets all the calls that were made to AddQueue.
// Check the length with:
//     len(mockedOrder.AddQueueCalls())
func (mock *OrderMock) AddQueueCalls() []struct {
	Ctx    context.Context
	Symbol string
} {
	var calls []struct {
		Ctx    context.Context
		Symbol string
	}
	mock.lockAddQueue.RLock()
	calls = mock.calls.AddQueue
	mock.lockAddQueue.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *OrderMock) Close() {
	if mock.CloseFunc == nil {
		panic("OrderMock.CloseFunc: method is nil but Order.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedOrder.CloseCalls())
func (mock *OrderMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Exists calls ExistsFunc.
func (mock *OrderMock) Exists(ctx context.Context, symbol string) bool {
	if mock.ExistsFunc == nil {
		panic("OrderMock.ExistsFunc: method is nil but Order.Exists was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Symbol string
	}{
		Ctx:    ctx,
		Symbol: symbol,
	}
	mock.lockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	mock.lockExists.Unlock()
	return mock.ExistsFunc(ctx, symbol)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//     len(mockedOrder.ExistsCalls())
func (mock *OrderMock) ExistsCalls() []struct {
	Ctx    context.Context
	Symbol string
} {
	var calls []struct {
		Ctx    context.Context
		Symbol string
	}
	mock.lockExists.RLock()
	calls = mock.calls.Exists
	mock.lockExists.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *OrderMock) Get(ctx context.Context, symbol string, orderId int64) (*models.Order, error) {
	if mock.GetFunc == nil {
		panic("OrderMock.GetFunc: method is nil but Order.Get was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Symbol  string
		OrderId int64
	}{
		Ctx:     ctx,
		Symbol:  symbol,
		OrderId: orderId,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, symbol, orderId)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedOrder.GetCalls())
func (mock *OrderMock) GetCalls() []struct {
	Ctx     context.Context
	Symbol  string
	OrderId int64
} {
	var calls []struct {
		Ctx     context.Context
		Symbol  string
		OrderId int64
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetAll calls GetAllFunc.
func (mock *OrderMock) GetAll(ctx context.Context, symbol string) ([]*models.Order, error) {
	if mock.GetAllFunc == nil {
		panic("OrderMock.GetAllFunc: method is nil but Order.GetAll was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Symbol string
	}{
		Ctx:    ctx,
		Symbol: symbol,
	}
	mock.lockGetAll.Lock()
	mock.calls.GetAll = append(mock.calls.GetAll, callInfo)
	mock.lockGetAll.Unlock()
	return mock.GetAllFunc(ctx, symbol)
}

// GetAllCalls gets all the calls that were made to GetAll.
// Check the length with:
//     len(mockedOrder.GetAllCalls())
func (mock *OrderMock) GetAllCalls() []struct {
	Ctx    context.Context
	Symbol string
} {
	var calls []struct {
		Ctx    context.Context
		Symbol string
	}
	mock.lockGetAll.RLock()
	calls = mock.calls.GetAll
	mock.lockGetAll.RUnlock()
	return calls
}

// MSet calls MSetFunc.
func (mock *OrderMock) MSet(ctx context.Context, symbol string, orders ...*models.Order) error {
	if mock.MSetFunc == nil {
		panic("OrderMock.MSetFunc: method is nil but Order.MSet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Symbol string
		Orders []*models.Order
	}{
		Ctx:    ctx,
		Symbol: symbol,
		Orders: orders,
	}
	mock.lockMSet.Lock()
	mock.calls.MSet = append(mock.calls.MSet, callInfo)
	mock.lockMSet.Unlock()
	return mock.MSetFunc(ctx, symbol, orders...)
}

// MSetCalls gets all the calls that were made to MSet.
// Check the length with:
//     len(mockedOrder.MSetCalls())
func (mock *OrderMock) MSetCalls() []struct {
	Ctx    context.Context
	Symbol string
	Orders []*models.Order
} {
	var calls []struct {
		Ctx    context.Context
		Symbol string
		Orders []*models.Order
	}
	mock.lockMSet.RLock()
	calls = mock.calls.MSet
	mock.lockMSet.RUnlock()
	return calls
}

// PopQueue calls PopQueueFunc.
func (mock *OrderMock) PopQueue(ctx context.Context) (string, error) {
	if mock.PopQueueFunc == nil {
		panic("OrderMock.PopQueueFunc: method is nil but Order.PopQueue was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPopQueue.Lock()
	mock.calls.PopQueue = append(mock.calls.PopQueue, callInfo)
	mock.lockPopQueue.Unlock()
	return mock.PopQueueFunc(ctx)
}

// PopQueueCalls gets all the calls that were made to PopQueue.
// Check the length with:
//     len(mockedOrder.PopQueueCalls())
func (mock *OrderMock) PopQueueCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPopQueue.RLock()
	calls = mock.calls.PopQueue
	mock.lockPopQueue.RUnlock()
	return calls
}

// RemoveQueue calls RemoveQueueFunc.
func (mock *OrderMock) RemoveQueue(ctx context.Context, symbol string) error {
	if mock.RemoveQueueFunc == nil {
		panic("OrderMock.RemoveQueueFunc: method is nil but Order.RemoveQueue was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Symbol string
	}{
		Ctx:    ctx,
		Symbol: symbol,
	}
	mock.lockRemoveQueue.Lock()
	mock.calls.RemoveQueue = append(mock.calls.RemoveQueue, callInfo)
	mock.lockRemoveQueue.Unlock()
	return mock.RemoveQueueFunc(ctx, symbol)
}

// RemoveQueueCalls gets all the calls that were made to RemoveQueue.
// Check the length with:
//     len(mockedOrder.RemoveQueueCalls())
func (mock *OrderMock) RemoveQueueCalls() []struct {
	Ctx    context.Context
	Symbol string
} {
	var calls []struct {
		Ctx    context.Context
		Symbol string
	}
	mock.lockRemoveQueue.RLock()
	calls = mock.calls.RemoveQueue
	mock.lockRemoveQueue.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *OrderMock) Set(ctx context.Context, order *models.Order) error {
	if mock.SetFunc == nil {
		panic("OrderMock.SetFunc: method is nil but Order.Set was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Order *models.Order
	}{
		Ctx:   ctx,
		Order: order,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	return mock.SetFunc(ctx, order)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//     len(mockedOrder.SetCalls())
func (mock *OrderMock) SetCalls() []struct {
	Ctx   context.Context
	Order *models.Order
} {
	var calls []struct {
		Ctx   context.Context
		Order *models.Order
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}
